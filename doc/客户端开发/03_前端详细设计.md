# å‰ç«¯è¯¦ç»†è®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

**æ–‡æ¡£åç§°**: å‰ç«¯è¯¦ç»†è®¾è®¡æ–‡æ¡£  
**é¡¹ç›®åç§°**: åŸºäºæ¯”ç‰¹æ‰¿è¯ºæ¨¡å‹çš„å»ä¸­å¿ƒåŒ–æŠ•ç¥¨ç³»ç»Ÿ  
**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**åˆ›å»ºæ—¶é—´**: 2025å¹´8æœˆ  
**æ–‡æ¡£çŠ¶æ€**: è¯¦ç»†è®¾è®¡å®Œæˆ  

## ğŸ—ï¸ é¡¹ç›®ç»“æ„è®¾è®¡

### ç›®å½•ç»“æ„
```
src/
â”œâ”€â”€ components/           # é€šç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ common/          # åŸºç¡€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”œâ”€â”€ Input/
â”‚   â”‚   â”œâ”€â”€ Card/
â”‚   â”‚   â”œâ”€â”€ Modal/
â”‚   â”‚   â””â”€â”€ Table/
â”‚   â”œâ”€â”€ layout/          # å¸ƒå±€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ Header/
â”‚   â”‚   â”œâ”€â”€ Sidebar/
â”‚   â”‚   â”œâ”€â”€ Footer/
â”‚   â”‚   â””â”€â”€ PageLayout/
â”‚   â””â”€â”€ business/        # ä¸šåŠ¡ç»„ä»¶
â”‚       â”œâ”€â”€ voting/      # æŠ•ç¥¨ç›¸å…³
â”‚       â”œâ”€â”€ nft/         # NFTç›¸å…³
â”‚       â”œâ”€â”€ token/       # ä»£å¸ç›¸å…³
â”‚       â””â”€â”€ admin/       # ç®¡ç†ç›¸å…³
â”œâ”€â”€ pages/               # é¡µé¢ç»„ä»¶
â”‚   â”œâ”€â”€ Dashboard/
â”‚   â”œâ”€â”€ Voting/
â”‚   â”œâ”€â”€ NFT/
â”‚   â”œâ”€â”€ Token/
â”‚   â””â”€â”€ Admin/
â”œâ”€â”€ hooks/               # è‡ªå®šä¹‰Hooks
â”œâ”€â”€ services/            # æœåŠ¡å±‚
â”œâ”€â”€ store/               # çŠ¶æ€ç®¡ç†
â”œâ”€â”€ utils/               # å·¥å…·å‡½æ•°
â”œâ”€â”€ types/               # ç±»å‹å®šä¹‰
â”œâ”€â”€ styles/              # æ ·å¼æ–‡ä»¶
â””â”€â”€ assets/              # é™æ€èµ„æº
```

### æ–‡ä»¶å‘½åè§„èŒƒ
- **ç»„ä»¶æ–‡ä»¶**: PascalCase (å¦‚: `VotingList.tsx`)
- **å·¥å…·æ–‡ä»¶**: camelCase (å¦‚: `apiClient.ts`)
- **ç±»å‹æ–‡ä»¶**: camelCase (å¦‚: `votingTypes.ts`)
- **æ ·å¼æ–‡ä»¶**: camelCase (å¦‚: `votingStyles.ts`)

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è¯¦ç»†è®¾è®¡

### 1. ç”¨æˆ·è®¤è¯æ¨¡å—

#### 1.1 WalletConnect ç»„ä»¶
```typescript
// src/components/common/WalletConnect/WalletConnect.tsx
import React, { useState, useEffect } from 'react';
import { useWallet } from '../../hooks/useWallet';
import { WalletButton, WalletStatus } from './components';

interface WalletConnectProps {
  onConnect?: (wallet: WalletInfo) => void;
  onDisconnect?: () => void;
  className?: string;
}

export const WalletConnect: React.FC<WalletConnectProps> = ({
  onConnect,
  onDisconnect,
  className
}) => {
  const { wallet, isConnected, connect, disconnect } = useWallet();
  const [isConnecting, setIsConnecting] = useState(false);

  const handleConnect = async () => {
    setIsConnecting(true);
    try {
      const walletInfo = await connect();
      onConnect?.(walletInfo);
    } catch (error) {
      console.error('Wallet connection failed:', error);
    } finally {
      setIsConnecting(false);
    }
  };

  const handleDisconnect = () => {
    disconnect();
    onDisconnect?.();
  };

  return (
    <div className={`wallet-connect ${className}`}>
      {!isConnected ? (
        <WalletButton
          onClick={handleConnect}
          disabled={isConnecting}
          loading={isConnecting}
        >
          {isConnecting ? 'è¿æ¥ä¸­...' : 'è¿æ¥é’±åŒ…'}
        </WalletButton>
      ) : (
        <WalletStatus
          wallet={wallet}
          onDisconnect={handleDisconnect}
        />
      )}
    </div>
  );
};
```

#### 1.2 PermissionGuard ç»„ä»¶
```typescript
// src/components/common/PermissionGuard/PermissionGuard.tsx
import React from 'react';
import { usePermissions } from '../../hooks/usePermissions';

interface PermissionGuardProps {
  requiredPermission: string;
  fallback?: React.ReactNode;
  children: React.ReactNode;
}

export const PermissionGuard: React.FC<PermissionGuardProps> = ({
  requiredPermission,
  fallback,
  children
}) => {
  const { hasPermission, isLoading } = usePermissions();

  if (isLoading) {
    return <div>æƒé™æ£€æŸ¥ä¸­...</div>;
  }

  if (!hasPermission(requiredPermission)) {
    return fallback || (
      <div className="permission-denied">
        <h3>æƒé™ä¸è¶³</h3>
        <p>æ‚¨æ²¡æœ‰æ‰§è¡Œæ­¤æ“ä½œçš„æƒé™</p>
        <p>æ‰€éœ€æƒé™: {requiredPermission}</p>
      </div>
    );
  }

  return <>{children}</>;
};
```

### 2. æŠ•ç¥¨ç®¡ç†æ¨¡å—

#### 2.1 VotingList ç»„ä»¶
```typescript
// src/components/business/voting/VotingList/VotingList.tsx
import React, { useState, useEffect } from 'react';
import { useVotingSessions } from '../../../hooks/useVotingSessions';
import { VotingCard, VotingFilters, Pagination } from './components';
import { VotingSession, VotingFilters as Filters } from '../../../types';

interface VotingListProps {
  onVotingSelect?: (voting: VotingSession) => void;
  showCreateButton?: boolean;
  className?: string;
}

export const VotingList: React.FC<VotingListProps> = ({
  onVotingSelect,
  showCreateButton = true,
  className
}) => {
  const [filters, setFilters] = useState<Filters>({
    status: 'all',
    type: 'all',
    search: ''
  });
  const [page, setPage] = useState(1);
  const [pageSize] = useState(10);

  const {
    sessions,
    isLoading,
    error,
    refetch
  } = useVotingSessions({ filters, page, pageSize });

  const handleVotingSelect = (voting: VotingSession) => {
    onVotingSelect?.(voting);
  };

  const handleFiltersChange = (newFilters: Partial<Filters>) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
    setPage(1);
  };

  const handlePageChange = (newPage: number) => {
    setPage(newPage);
  };

  if (error) {
    return (
      <div className="error-container">
        <h3>åŠ è½½å¤±è´¥</h3>
        <p>{error.message}</p>
        <button onClick={() => refetch()}>é‡è¯•</button>
      </div>
    );
  }

  return (
    <div className={`voting-list ${className}`}>
      <div className="voting-list-header">
        <h2>æŠ•ç¥¨åˆ—è¡¨</h2>
        {showCreateButton && (
          <button className="create-voting-btn">
            åˆ›å»ºæŠ•ç¥¨
          </button>
        )}
      </div>

      <VotingFilters
        filters={filters}
        onFiltersChange={handleFiltersChange}
      />

      <div className="voting-list-content">
        {isLoading ? (
          <div className="loading-container">
            <div className="loading-spinner" />
            <p>åŠ è½½ä¸­...</p>
          </div>
        ) : sessions.length === 0 ? (
          <div className="empty-container">
            <p>æš‚æ— æŠ•ç¥¨</p>
          </div>
        ) : (
          <div className="voting-grid">
            {sessions.map(session => (
              <VotingCard
                key={session.id}
                voting={session}
                onClick={() => handleVotingSelect(session)}
              />
            ))}
          </div>
        )}
      </div>

      {sessions.length > 0 && (
        <Pagination
          currentPage={page}
          totalPages={Math.ceil(sessions.length / pageSize)}
          onPageChange={handlePageChange}
        />
      )}
    </div>
  );
};
```

#### 2.2 VotingDetail ç»„ä»¶
```typescript
// src/components/business/voting/VotingDetail/VotingDetail.tsx
import React, { useState, useEffect } from 'react';
import { useVotingSession } from '../../../hooks/useVotingSession';
import { useVotingActions } from '../../../hooks/useVotingActions';
import {
  VotingInfo,
  VotingProgress,
  VotingActions,
  ParticipantsList,
  VotingResults
} from './components';
import { VotingSession } from '../../../types';

interface VotingDetailProps {
  votingId: string;
  onBack?: () => void;
  className?: string;
}

export const VotingDetail: React.FC<VotingDetailProps> = ({
  votingId,
  onBack,
  className
}) => {
  const [activeTab, setActiveTab] = useState<'info' | 'participants' | 'results'>('info');
  
  const {
    session,
    isLoading,
    error,
    refetch
  } = useVotingSession(votingId);

  const {
    submitCommitment,
    submitReveal,
    isSubmitting,
    submissionError
  } = useVotingActions(votingId);

  useEffect(() => {
    if (session) {
      // æ ¹æ®æŠ•ç¥¨çŠ¶æ€è‡ªåŠ¨åˆ‡æ¢æ ‡ç­¾
      if (session.state === 'Completed') {
        setActiveTab('results');
      }
    }
  }, [session]);

  const handleCommitmentSubmit = async (data: CommitmentData) => {
    try {
      await submitCommitment(data);
      refetch();
    } catch (error) {
      console.error('Commitment submission failed:', error);
    }
  };

  const handleRevealSubmit = async (data: RevealData) => {
    try {
      await submitReveal(data);
      refetch();
    } catch (error) {
      console.error('Reveal submission failed:', error);
    }
  };

  if (isLoading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner" />
        <p>åŠ è½½æŠ•ç¥¨è¯¦æƒ…ä¸­...</p>
      </div>
    );
  }

  if (error || !session) {
    return (
      <div className="error-container">
        <h3>åŠ è½½å¤±è´¥</h3>
        <p>{error?.message || 'æŠ•ç¥¨ä¸å­˜åœ¨'}</p>
        <button onClick={() => refetch()}>é‡è¯•</button>
        {onBack && (
          <button onClick={onBack}>è¿”å›åˆ—è¡¨</button>
        )}
      </div>
    );
  }

  return (
    <div className={`voting-detail ${className}`}>
      <div className="voting-detail-header">
        <button className="back-button" onClick={onBack}>
          â† è¿”å›
        </button>
        <h1>{session.title}</h1>
        <VotingProgress session={session} />
      </div>

      <div className="voting-detail-tabs">
        <button
          className={`tab-button ${activeTab === 'info' ? 'active' : ''}`}
          onClick={() => setActiveTab('info')}
        >
          æŠ•ç¥¨ä¿¡æ¯
        </button>
        <button
          className={`tab-button ${activeTab === 'participants' ? 'active' : ''}`}
          onClick={() => setActiveTab('participants')}
        >
          å‚ä¸è€…
        </button>
        <button
          className={`tab-button ${activeTab === 'results' ? 'active' : ''}`}
          onClick={() => setActiveTab('results')}
        >
          ç»“æœ
        </button>
      </div>

      <div className="voting-detail-content">
        {activeTab === 'info' && (
          <VotingInfo session={session} />
        )}
        
        {activeTab === 'participants' && (
          <ParticipantsList session={session} />
        )}
        
        {activeTab === 'results' && (
          <VotingResults session={session} />
        )}
      </div>

      <VotingActions
        session={session}
        onSubmitCommitment={handleCommitmentSubmit}
        onSubmitReveal={handleRevealSubmit}
        isSubmitting={isSubmitting}
        error={submissionError}
      />
    </div>
  );
};
```

### 3. NFTç®¡ç†æ¨¡å—

#### 3.1 NFTGallery ç»„ä»¶
```typescript
// src/components/business/nft/NFTGallery/NFTGallery.tsx
import React, { useState, useEffect } from 'react';
import { useNFTs } from '../../../hooks/useNFTs';
import { NFTCard, NFTFilters, NFTGrid } from './components';
import { NFT, NFTFilters as Filters } from '../../../types';

interface NFTGalleryProps {
  onNFTSelect?: (nft: NFT) => void;
  showCreateButton?: boolean;
  className?: string;
}

export const NFTGallery: React.FC<NFTGalleryProps> = ({
  onNFTSelect,
  showCreateButton = false,
  className
}) => {
  const [filters, setFilters] = useState<Filters>({
    type: 'all',
    status: 'all',
    search: ''
  });
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');

  const {
    nfts,
    isLoading,
    error,
    refetch
  } = useNFTs({ filters });

  const handleNFTSelect = (nft: NFT) => {
    onNFTSelect?.(nft);
  };

  const handleFiltersChange = (newFilters: Partial<Filters>) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
  };

  if (error) {
    return (
      <div className="error-container">
        <h3>åŠ è½½å¤±è´¥</h3>
        <p>{error.message}</p>
        <button onClick={() => refetch()}>é‡è¯•</button>
      </div>
    );
  }

  return (
    <div className={`nft-gallery ${className}`}>
      <div className="nft-gallery-header">
        <h2>æˆ‘çš„NFT</h2>
        <div className="nft-gallery-controls">
          <NFTFilters
            filters={filters}
            onFiltersChange={handleFiltersChange}
          />
          <div className="view-mode-toggle">
            <button
              className={`toggle-btn ${viewMode === 'grid' ? 'active' : ''}`}
              onClick={() => setViewMode('grid')}
            >
              <GridIcon />
            </button>
            <button
              className={`toggle-btn ${viewMode === 'list' ? 'active' : ''}`}
              onClick={() => setViewMode('list')}
            >
              <ListIcon />
            </button>
          </div>
        </div>
      </div>

      <div className="nft-gallery-content">
        {isLoading ? (
          <div className="loading-container">
            <div className="loading-spinner" />
            <p>åŠ è½½ä¸­...</p>
          </div>
        ) : nfts.length === 0 ? (
          <div className="empty-container">
            <p>æš‚æ— NFT</p>
          </div>
        ) : (
          <NFTGrid
            nfts={nfts}
            viewMode={viewMode}
            onNFTSelect={handleNFTSelect}
          />
        )}
      </div>
    </div>
  );
};
```

### 4. æ²»ç†ä»£å¸ç®¡ç†æ¨¡å—

#### 4.1 GovernanceTokenBalance ç»„ä»¶
```typescript
// src/components/business/governance/GovernanceTokenBalance/GovernanceTokenBalance.tsx
import React from 'react';
import { useGovernanceToken } from '../../../hooks/useGovernanceToken';
import { TokenBalanceCard, PermissionLevelCard, GovernanceStats } from './components';

interface GovernanceTokenBalanceProps {
  className?: string;
}

export const GovernanceTokenBalance: React.FC<GovernanceTokenBalanceProps> = ({ className }) => {
  const {
    tokenBalance,
    permissionLevel,
    governanceStats,
    isLoading,
    error,
    refetch
  } = useGovernanceToken();

  if (isLoading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner" />
        <p>åŠ è½½å»ä¸­å¿ƒåŒ–å†³ç­–æ²»ç†ä»£å¸DDGä¿¡æ¯ä¸­...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="error-container">
        <h3>åŠ è½½å¤±è´¥</h3>
        <p>{error.message}</p>
        <button onClick={() => refetch()}>é‡è¯•</button>
      </div>
    );
  }

  return (
    <div className={`governance-token-balance ${className}`}>
      <h2>å»ä¸­å¿ƒåŒ–å†³ç­–æ²»ç†ä»£å¸DDGä¿¡æ¯</h2>
      
      <div className="balance-overview">
        <TokenBalanceCard
          title="å»ä¸­å¿ƒåŒ–å†³ç­–æ²»ç†ä»£å¸DDGä½™é¢"
          amount={tokenBalance.total}
          symbol="DDG"
          icon="governance"
        />
        
        <TokenBalanceCard
          title="å¯ç”¨ä½™é¢"
          amount={tokenBalance.available}
          symbol="LUCKEE"
          icon="wallet"
        />
        
        <TokenBalanceCard
          title="è´¨æŠ¼ä½™é¢"
          amount={tokenBalance.staked}
          symbol="LUCKEE"
          icon="lock"
        />
      </div>

      <div className="permission-info">
        <PermissionLevelCard
          level={permissionLevel.level}
          requirements={permissionLevel.requirements}
          nextLevel={permissionLevel.nextLevel}
        />
      </div>

      <div className="governance-stats">
        <GovernanceStats stats={governanceStats} />
      </div>
    </div>
  );
};
```

#### 4.2 PermissionLevelDisplay ç»„ä»¶
```typescript
// src/components/business/governance/PermissionLevelDisplay/PermissionLevelDisplay.tsx
import React from 'react';
import { usePermissionLevel } from '../../../hooks/usePermissionLevel';

interface PermissionLevelDisplayProps {
  className?: string;
}

export const PermissionLevelDisplay: React.FC<PermissionLevelDisplayProps> = ({ className }) => {
  const {
    currentLevel,
    nextLevel,
    requirements,
    isLoading
  } = usePermissionLevel();

  if (isLoading) {
    return <div>åŠ è½½æƒé™ä¿¡æ¯ä¸­...</div>;
  }

  return (
    <div className={`permission-level-display ${className}`}>
      <div className="current-level">
        <h3>å½“å‰æƒé™ç­‰çº§</h3>
        <div className={`level-badge level-${currentLevel.toLowerCase()}`}>
          {currentLevel}
        </div>
        <p className="level-description">
          {getLevelDescription(currentLevel)}
        </p>
      </div>

      {nextLevel && (
        <div className="next-level">
          <h4>ä¸‹ä¸€ç­‰çº§: {nextLevel.level}</h4>
          <p>éœ€è¦æŒæœ‰: {nextLevel.requiredBalance} LUCKEE</p>
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ width: `${requirements.progress}%` }}
            />
          </div>
          <p>è¿˜éœ€: {requirements.remaining} LUCKEE</p>
        </div>
      )}

      <div className="level-benefits">
        <h4>å½“å‰ç­‰çº§æƒç›Š</h4>
        <ul>
          {getLevelBenefits(currentLevel).map((benefit, index) => (
            <li key={index}>{benefit}</li>
          ))}
        </ul>
      </div>
    </div>
  );
};

function getLevelDescription(level: string): string {
  switch (level) {
    case 'Basic': return 'åŸºç¡€ç”¨æˆ·ï¼Œå¯ä»¥å‚ä¸æŠ•ç¥¨å’ŒæŸ¥çœ‹ä¿¡æ¯';
    case 'Creator': return 'åˆ›å»ºè€…ï¼Œå¯ä»¥åˆ›å»ºNFTç±»å‹å’ŒæŠ•ç¥¨ä¼šè¯';
    case 'Admin': return 'é«˜çº§æ²»ç†è€…ï¼Œå¯ä»¥å‚ä¸ç³»ç»Ÿæ²»ç†å’Œå‚æ•°è°ƒæ•´';
    default: return 'æœªçŸ¥æƒé™ç­‰çº§';
  }
}

function getLevelBenefits(level: string): string[] {
  switch (level) {
    case 'Basic': return ['å‚ä¸æŠ•ç¥¨', 'æŸ¥çœ‹ç»“æœ', 'æŒæœ‰NFT'];
    case 'Creator': return ['åˆ›å»ºNFTç±»å‹', 'åˆ›å»ºæŠ•ç¥¨ä¼šè¯', 'ç®¡ç†æŠ•ç¥¨'];
    case 'Admin': return ['å‚ä¸æ²»ç†', 'å‚æ•°è°ƒæ•´', 'ç´§æ€¥å¤„ç†'];
    default: return [];
  }
}
```

## ğŸ¨ æ ·å¼è®¾è®¡è§„èŒƒ

### 1. è®¾è®¡ç³»ç»Ÿ

#### 1.1 é¢œè‰²ç³»ç»Ÿ
```scss
// src/styles/variables/_colors.scss
:root {
  // ä¸»è‰²è°ƒ
  --primary-color: #1976d2;
  --primary-light: #42a5f5;
  --primary-dark: #1565c0;
  
  // è¾…åŠ©è‰²
  --secondary-color: #dc004e;
  --secondary-light: #ff5983;
  --secondary-dark: #9a0036;
  
  // æˆåŠŸè‰²
  --success-color: #2e7d32;
  --success-light: #4caf50;
  --success-dark: #1b5e20;
  
  // è­¦å‘Šè‰²
  --warning-color: #ed6c02;
  --warning-light: #ff9800;
  --warning-dark: #e65100;
  
  // é”™è¯¯è‰²
  --error-color: #d32f2f;
  --error-light: #f44336;
  --error-dark: #c62828;
  
  // ä¸­æ€§è‰²
  --text-primary: rgba(0, 0, 0, 0.87);
  --text-secondary: rgba(0, 0, 0, 0.6);
  --text-disabled: rgba(0, 0, 0, 0.38);
  
  --background-default: #ffffff;
  --background-paper: #fafafa;
  --background-dark: #303030;
  
  --divider: rgba(0, 0, 0, 0.12);
  --border: rgba(0, 0, 0, 0.23);
}
```

#### 1.2 å­—ä½“ç³»ç»Ÿ
```scss
// src/styles/variables/_typography.scss
:root {
  // å­—ä½“æ—
  --font-family-primary: 'Roboto', 'Helvetica', 'Arial', sans-serif;
  --font-family-mono: 'Roboto Mono', 'Consolas', 'Monaco', monospace;
  
  // å­—ä½“å¤§å°
  --font-size-xs: 0.75rem;    // 12px
  --font-size-sm: 0.875rem;   // 14px
  --font-size-md: 1rem;       // 16px
  --font-size-lg: 1.125rem;   // 18px
  --font-size-xl: 1.25rem;    // 20px
  --font-size-xxl: 1.5rem;    // 24px
  
  // å­—ä½“æƒé‡
  --font-weight-light: 300;
  --font-weight-regular: 400;
  --font-weight-medium: 500;
  --font-weight-bold: 700;
  
  // è¡Œé«˜
  --line-height-tight: 1.2;
  --line-height-normal: 1.5;
  --line-height-relaxed: 1.8;
}
```

#### 1.3 é—´è·ç³»ç»Ÿ
```scss
// src/styles/variables/_spacing.scss
:root {
  // åŸºç¡€é—´è·å•ä½
  --spacing-unit: 8px;
  
  // é—´è·å€¼
  --spacing-xs: calc(var(--spacing-unit) * 0.5);   // 4px
  --spacing-sm: var(--spacing-unit);                // 8px
  --spacing-md: calc(var(--spacing-unit) * 1.5);   // 12px
  --spacing-lg: calc(var(--spacing-unit) * 2);     // 16px
  --spacing-xl: calc(var(--spacing-unit) * 3);     // 24px
  --spacing-xxl: calc(var(--spacing-unit) * 4);    // 32px
  
  // ç»„ä»¶é—´è·
  --component-padding: var(--spacing-md);
  --component-margin: var(--spacing-md);
  --section-spacing: var(--spacing-xl);
  --page-spacing: var(--spacing-xxl);
}
```

### 2. ç»„ä»¶æ ·å¼

#### 2.1 Button ç»„ä»¶æ ·å¼
```scss
// src/components/common/Button/Button.scss
.button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--spacing-sm) var(--spacing-md);
  border: none;
  border-radius: 4px;
  font-family: var(--font-family-primary);
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-medium);
  line-height: var(--line-height-normal);
  text-decoration: none;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
  
  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
  
  // å˜ä½“æ ·å¼
  &--primary {
    background-color: var(--primary-color);
    color: white;
    
    &:hover:not(:disabled) {
      background-color: var(--primary-dark);
    }
  }
  
  &--secondary {
    background-color: transparent;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
    
    &:hover:not(:disabled) {
      background-color: var(--primary-color);
      color: white;
    }
  }
  
  &--outlined {
    background-color: transparent;
    color: var(--text-primary);
    border: 1px solid var(--border);
    
    &:hover:not(:disabled) {
      background-color: var(--background-paper);
      border-color: var(--primary-color);
    }
  }
  
  // å°ºå¯¸æ ·å¼
  &--small {
    padding: var(--spacing-xs) var(--spacing-sm);
    font-size: var(--font-size-sm);
  }
  
  &--large {
    padding: var(--spacing-md) var(--spacing-lg);
    font-size: var(--font-size-lg);
  }
}
```

## ğŸ”„ çŠ¶æ€ç®¡ç†è®¾è®¡

### 1. Redux Store ç»“æ„

#### 1.1 Store é…ç½®
```typescript
// src/store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import { api } from './api';
import authReducer from './slices/authSlice';
import votingReducer from './slices/votingSlice';
import nftReducer from './slices/nftSlice';
import tokenReducer from './slices/tokenSlice';
import uiReducer from './slices/uiSlice';

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer,
    auth: authReducer,
    voting: votingReducer,
    nft: nftReducer,
    token: tokenReducer,
    ui: uiReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware),
  devTools: process.env.NODE_ENV !== 'production',
});

setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

#### 1.2 Auth Slice
```typescript
// src/store/slices/authSlice.ts
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { WalletInfo, UserPermissions, PermissionLevel } from '../../types';

interface AuthState {
  wallet: WalletInfo | null;
  permissions: UserPermissions | null;
  governanceTokenBalance: number;
  permissionLevel: PermissionLevel;
  isConnected: boolean;
  isLoading: boolean;
  error: string | null;
}

const initialState: AuthState = {
  wallet: null,
  permissions: null,
  governanceTokenBalance: 0,
  permissionLevel: PermissionLevel.Basic,
  isConnected: false,
  isLoading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setWallet: (state, action: PayloadAction<WalletInfo>) => {
      state.wallet = action.payload;
      state.isConnected = true;
      state.error = null;
    },
    setPermissions: (state, action: PayloadAction<UserPermissions>) => {
      state.permissions = action.payload;
    },
    setGovernanceTokenBalance: (state, action: PayloadAction<number>) => {
      state.governanceTokenBalance = action.payload;
      // è‡ªåŠ¨è®¡ç®—æƒé™ç­‰çº§
      state.permissionLevel = calculatePermissionLevel(action.payload);
    },
    setPermissionLevel: (state, action: PayloadAction<PermissionLevel>) => {
      state.permissionLevel = action.payload;
    },
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.isLoading = action.payload;
    },
    setError: (state, action: PayloadAction<string>) => {
      state.error = action.payload;
    },
    disconnect: (state) => {
      state.wallet = null;
      state.permissions = null;
      state.governanceTokenBalance = 0;
      state.permissionLevel = PermissionLevel.Basic;
      state.isConnected = false;
      state.error = null;
    },
  },
});

// åŸºäºä»£å¸ä½™é¢è‡ªåŠ¨è®¡ç®—æƒé™ç­‰çº§
function calculatePermissionLevel(balance: number): PermissionLevel {
  if (balance >= 100000) {
    return PermissionLevel.Admin;
  } else if (balance >= 1000) {
    return PermissionLevel.Creator;
  } else {
    return PermissionLevel.Basic;
  }
}

export const {
  setWallet,
  setPermissions,
  setGovernanceTokenBalance,
  setPermissionLevel,
  setLoading,
  setError,
  disconnect,
} = authSlice.actions;

export default authSlice.reducer;
```

### 2. RTK Query API

#### 2.1 API é…ç½®
```typescript
// src/store/api/index.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { RootState } from '../index';

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({
    baseUrl: process.env.REACT_APP_API_BASE_URL || 'http://localhost:8080',
    prepareHeaders: (headers, { getState }) => {
      const state = getState() as RootState;
      if (state.auth.wallet?.address) {
        headers.set('x-address', state.auth.wallet.address);
      }
      return headers;
    },
  }),
  tagTypes: ['Voting', 'NFT', 'Token', 'User'],
  endpoints: () => ({}),
});
```

#### 2.2 æŠ•ç¥¨ API
```typescript
// src/store/api/votingApi.ts
import { api } from './index';
import { VotingSession, CreateVotingRequest, VotingFilters } from '../../types';

export const votingApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getVotingSessions: builder.query<VotingSession[], VotingFilters>({
      query: (filters) => ({
        url: '/sessions',
        params: filters,
      }),
      providesTags: ['Voting'],
    }),
    
    getVotingSession: builder.query<VotingSession, string>({
      query: (id) => `/sessions/${id}`,
      providesTags: (result, error, id) => [{ type: 'Voting', id }],
    }),
    
    createVotingSession: builder.mutation<VotingSession, CreateVotingRequest>({
      query: (body) => ({
        url: '/sessions',
        method: 'POST',
        body,
      }),
      invalidatesTags: ['Voting'],
    }),
    
    submitCommitment: builder.mutation<void, { sessionId: string; data: any }>({
      query: ({ sessionId, data }) => ({
        url: `/sessions/${sessionId}/commitments`,
        method: 'POST',
        body: data,
      }),
      invalidatesTags: (result, error, { sessionId }) => [
        { type: 'Voting', id: sessionId }
      ],
    }),
    
    submitReveal: builder.mutation<void, { sessionId: string; data: any }>({
      query: ({ sessionId, data }) => ({
        url: `/sessions/${sessionId}/reveals`,
        method: 'POST',
        body: data,
      }),
      invalidatesTags: (result, error, { sessionId }) => [
        { type: 'Voting', id: sessionId }
      ],
    }),
  }),
});

export const {
  useGetVotingSessionsQuery,
  useGetVotingSessionQuery,
  useCreateVotingSessionMutation,
  useSubmitCommitmentMutation,
  useSubmitRevealMutation,
} = votingApi;
```

## ğŸ§ª æµ‹è¯•è®¾è®¡

### 1. ç»„ä»¶æµ‹è¯•

#### 1.1 VotingList æµ‹è¯•
```typescript
// src/components/business/voting/VotingList/__tests__/VotingList.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import { VotingList } from '../VotingList';
import { votingApi } from '../../../../store/api/votingApi';

const mockStore = configureStore({
  reducer: {
    [votingApi.reducerPath]: votingApi.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(votingApi.middleware),
});

const mockVotingSessions = [
  {
    id: '1',
    title: 'æµ‹è¯•æŠ•ç¥¨1',
    description: 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æŠ•ç¥¨',
    state: 'Active',
    participants: ['user1', 'user2'],
    created_at: Date.now(),
  },
  {
    id: '2',
    title: 'æµ‹è¯•æŠ•ç¥¨2',
    description: 'è¿™æ˜¯å¦ä¸€ä¸ªæµ‹è¯•æŠ•ç¥¨',
    state: 'Completed',
    participants: ['user3', 'user4'],
    created_at: Date.now(),
  },
];

describe('VotingList', () => {
  beforeEach(() => {
    // Mock API response
    jest.spyOn(global, 'fetch').mockResolvedValue({
      ok: true,
      json: async () => mockVotingSessions,
    } as Response);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('renders voting list correctly', async () => {
    render(
      <Provider store={mockStore}>
        <VotingList />
      </Provider>
    );

    await waitFor(() => {
      expect(screen.getByText('æŠ•ç¥¨åˆ—è¡¨')).toBeInTheDocument();
      expect(screen.getByText('æµ‹è¯•æŠ•ç¥¨1')).toBeInTheDocument();
      expect(screen.getByText('æµ‹è¯•æŠ•ç¥¨2')).toBeInTheDocument();
    });
  });

  it('handles voting selection', async () => {
    const mockOnSelect = jest.fn();
    
    render(
      <Provider store={mockStore}>
        <VotingList onVotingSelect={mockOnSelect} />
      </Provider>
    );

    await waitFor(() => {
      const votingCard = screen.getByText('æµ‹è¯•æŠ•ç¥¨1');
      fireEvent.click(votingCard);
      expect(mockOnSelect).toHaveBeenCalledWith(mockVotingSessions[0]);
    });
  });

  it('shows loading state', () => {
    render(
      <Provider store={mockStore}>
        <VotingList />
      </Provider>
    );

    expect(screen.getByText('åŠ è½½ä¸­...')).toBeInTheDocument();
  });

  it('shows error state when API fails', async () => {
    jest.spyOn(global, 'fetch').mockRejectedValue(new Error('API Error'));

    render(
      <Provider store={mockStore}>
        <VotingList />
      </Provider>
    );

    await waitFor(() => {
      expect(screen.getByText('åŠ è½½å¤±è´¥')).toBeInTheDocument();
      expect(screen.getByText('API Error')).toBeInTheDocument();
    });
  });
});
```

### 2. Hook æµ‹è¯•

#### 2.1 useVotingSessions æµ‹è¯•
```typescript
// src/hooks/__tests__/useVotingSessions.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import { useVotingSessions } from '../useVotingSessions';
import { votingApi } from '../../store/api/votingApi';

const mockStore = configureStore({
  reducer: {
    [votingApi.reducerPath]: votingApi.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(votingApi.middleware),
});

describe('useVotingSessions', () => {
  it('fetches voting sessions successfully', async () => {
    const mockSessions = [
      { id: '1', title: 'Test Voting' },
      { id: '2', title: 'Another Voting' },
    ];

    jest.spyOn(global, 'fetch').mockResolvedValue({
      ok: true,
      json: async () => mockSessions,
    } as Response);

    const { result } = renderHook(
      () => useVotingSessions({ status: 'all' }),
      {
        wrapper: ({ children }) => (
          <Provider store={mockStore}>{children}</Provider>
        ),
      }
    );

    await waitFor(() => {
      expect(result.current.sessions).toEqual(mockSessions);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBe(null);
    });
  });

  it('handles API errors correctly', async () => {
    jest.spyOn(global, 'fetch').mockRejectedValue(new Error('Network Error'));

    const { result } = renderHook(
      () => useVotingSessions({ status: 'all' }),
      {
        wrapper: ({ children }) => (
          <Provider store={mockStore}>{children}</Provider>
        ),
      }
    );

    await waitFor(() => {
      expect(result.current.error).toBeTruthy();
      expect(result.current.isLoading).toBe(false);
    });
  });
});
```

## ğŸ“± ç§»åŠ¨ç«¯é¢„ç•™æ¥å£

### 1. å“åº”å¼ç»„ä»¶

#### 1.1 è§¦æ‘¸äº‹ä»¶å¤„ç†
```typescript
// src/hooks/useTouchEvents.ts
import { useState, useCallback } from 'react';

interface TouchPoint {
  x: number;
  y: number;
}

interface TouchEvents {
  onTouchStart: (e: React.TouchEvent) => void;
  onTouchMove: (e: React.TouchEvent) => void;
  onTouchEnd: (e: React.TouchEvent) => void;
  onSwipe: (direction: 'left' | 'right' | 'up' | 'down') => void;
}

export const useTouchEvents = (swipeThreshold = 50): TouchEvents => {
  const [touchStart, setTouchStart] = useState<TouchPoint | null>(null);
  const [touchEnd, setTouchEnd] = useState<TouchPoint | null>(null);

  const onTouchStart = useCallback((e: React.TouchEvent) => {
    setTouchEnd(null);
    setTouchStart({
      x: e.targetTouches[0].clientX,
      y: e.targetTouches[0].clientY,
    });
  }, []);

  const onTouchMove = useCallback((e: React.TouchEvent) => {
    setTouchEnd({
      x: e.targetTouches[0].clientX,
      y: e.targetTouches[0].clientY,
    });
  }, []);

  const onTouchEnd = useCallback(() => {
    if (!touchStart || !touchEnd) return;

    const distanceX = touchStart.x - touchEnd.x;
    const distanceY = touchStart.y - touchEnd.y;
    const isHorizontalSwipe = Math.abs(distanceX) > Math.abs(distanceY);

    if (isHorizontalSwipe) {
      if (Math.abs(distanceX) > swipeThreshold) {
        if (distanceX > 0) {
          // Swipe left
        } else {
          // Swipe right
        }
      }
    } else {
      if (Math.abs(distanceY) > swipeThreshold) {
        if (distanceY > 0) {
          // Swipe up
        } else {
          // Swipe down
        }
      }
    }
  }, [touchStart, touchEnd, swipeThreshold]);

  return {
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onSwipe: () => {}, // Placeholder for swipe callback
  };
};
```

#### 1.2 ç§»åŠ¨ç«¯å¯¼èˆªç»„ä»¶
```typescript
// src/components/layout/MobileNavigation/MobileNavigation.tsx
import React, { useState } from 'react';
import { useTouchEvents } from '../../../hooks/useTouchEvents';
import { MobileNavItem, MobileNavOverlay } from './components';

interface MobileNavigationProps {
  items: Array<{
    id: string;
    label: string;
    icon: React.ReactNode;
    path: string;
  }>;
  onNavigate: (path: string) => void;
  className?: string;
}

export const MobileNavigation: React.FC<MobileNavigationProps> = ({
  items,
  onNavigate,
  className
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const { onTouchStart, onTouchMove, onTouchEnd } = useTouchEvents();

  const handleItemClick = (path: string) => {
    onNavigate(path);
    setIsOpen(false);
  };

  const toggleMenu = () => {
    setIsOpen(!isOpen);
  };

  return (
    <div className={`mobile-navigation ${className}`}>
      <button
        className="mobile-nav-toggle"
        onClick={toggleMenu}
        aria-label="Toggle navigation menu"
      >
        <span className={`hamburger ${isOpen ? 'open' : ''}`} />
      </button>

      <MobileNavOverlay
        isOpen={isOpen}
        onClose={() => setIsOpen(false)}
        onTouchStart={onTouchStart}
        onTouchMove={onTouchMove}
        onTouchEnd={onTouchEnd}
      >
        <nav className="mobile-nav-menu">
          {items.map(item => (
            <MobileNavItem
              key={item.id}
              item={item}
              onClick={() => handleItemClick(item.path)}
            />
          ))}
        </nav>
      </MobileNavOverlay>
    </div>
  );
};
```

---

**æ–‡æ¡£ç¼–åˆ¶æ—¥æœŸ**ï¼š2025å¹´8æœˆ  
**æ–‡æ¡£ç¼–åˆ¶äºº**ï¼šluckeeDAOæŠ€æœ¯è¯„ä¼°å›¢é˜Ÿ  
**æ–‡æ¡£å®¡æ ¸äºº**ï¼šluckeeDAOç®¡ç†å§”å‘˜ä¼š  

**æœ€åæ›´æ–°**ï¼š2025-08  
**ç»´æŠ¤äºº**ï¼šæ–‡æ¡£ä¸æ¶æ„è”åˆç»„
